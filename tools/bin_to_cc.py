# tools/bin_to_cc.py
#!/usr/bin/env python3
import argparse
import os
import re

def sanitize_for_c_identifier(name):
    """Converts a string to a valid C identifier."""
    # Replace non-alphanumeric characters (and not underscore) with underscore
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    # If it starts with a digit, prepend an underscore
    if name and name[0].isdigit():
        name = '_' + name
    # If it's empty after sanitization (e.g. was "---"), provide a default
    if not name:
        return "_resource"
    return name

def main():
    parser = argparse.ArgumentParser(description="Convert binary file to C/C++ header and source.")
    parser.add_argument("--input", required=True, help="Input binary file path.")
    parser.add_argument("--output_h", required=True, help="Output header file path (.h).")
    parser.add_argument("--output_cpp", required=True, help="Output source file path (.cpp).")
    parser.add_argument("--resource_name", required=True, help="Base name for C variable and include guard.")
    args = parser.parse_args()

    c_var_name = sanitize_for_c_identifier(args.resource_name)
    header_basename = os.path.basename(args.output_h) # e.g., my_resource.h
    include_guard = f"__{sanitize_for_c_identifier(args.resource_name).upper()}_H__"

    try:
        with open(args.input, "rb") as f_in:
            data = f_in.read()
    except IOError as e:
        print(f"Error reading input file {args.input}: {e}")
        return 1

    # --- Generate Header File (.h) ---
    h_content = f"""\
// Generated by bin_to_cc.py
#ifndef {include_guard}
#define {include_guard}

#include <stddef.h> // For size_t

#ifdef __cplusplus
extern "C" {{
#endif

typedef struct {{
    const char* name;
    size_t size;
    const unsigned char* data;
}} __ResourceData_{c_var_name};

extern const __ResourceData_{c_var_name} {c_var_name};

#ifdef __cplusplus
}} // extern "C"
#endif

#endif // {include_guard}
"""
    try:
        os.makedirs(os.path.dirname(args.output_h), exist_ok=True)
        with open(args.output_h, "w") as f_h:
            f_h.write(h_content)
    except IOError as e:
        print(f"Error writing header file {args.output_h}: {e}")
        return 1

    # --- Generate Source File (.cpp) ---
    cpp_content_parts = []
    cpp_content_parts.append(f"// Generated by bin_to_cc.py\n")
    cpp_content_parts.append(f"#include \"{header_basename}\"\n") # Include using basename
    cpp_content_parts.append("#include <stddef.h> // For size_t, though ResourceData already implies it\n")

    cpp_content_parts.append(f"\n#ifdef __cplusplus\nextern \"C\" {{\n#endif\n")

    cpp_content_parts.append(f"static const unsigned char {c_var_name}_data[] = {{")
    if data:
        for i, byte in enumerate(data):
            if i % 12 == 0:
                cpp_content_parts.append("\n    ")
            cpp_content_parts.append(f"0x{byte:02X}, ")
        # Remove trailing comma and space if data was not empty
        cpp_content_parts[-1] = cpp_content_parts[-1].rstrip(', ')
    cpp_content_parts.append("\n};\n\n")

    cpp_content_parts.append(f"const __ResourceData_{c_var_name} {c_var_name} = {{\n")
    cpp_content_parts.append(f"    \"{args.resource_name}\",\n")
    cpp_content_parts.append(f"    sizeof({c_var_name}_data),\n")
    cpp_content_parts.append(f"    {c_var_name}_data\n")
    cpp_content_parts.append(f"}};\n")

    cpp_content_parts.append(f"\n#ifdef __cplusplus\n}} // extern \"C\"\n#endif\n")

    try:
        os.makedirs(os.path.dirname(args.output_cpp), exist_ok=True)
        with open(args.output_cpp, "w") as f_cpp:
            f_cpp.write("".join(cpp_content_parts))
    except IOError as e:
        print(f"Error writing source file {args.output_cpp}: {e}")
        return 1

    print(f"Successfully generated {args.output_h} and {args.output_cpp} for {args.resource_name}")
    return 0

if __name__ == "__main__":
    exit(main())